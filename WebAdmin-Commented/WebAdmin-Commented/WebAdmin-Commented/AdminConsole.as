package  {		import flash.display.*;	import flash.events.*;	import flash.text.*;	import flash.geom.*;	import flash.utils.*;	import flash.net.*;	import flash.system.*;	import flash.display.MovieClip;	import flash.display.Graphics;	import flash.display.Shape;	import flash.display.Sprite;	import flash.display.SimpleButton;	import com.frigidfish.Grid;	import flash.events.MouseEvent;	import com.greensock.*;	import com.greensock.easing.*;		import gs.TweenFilterLite;	import menu.*;	import ui.*;	import events.*;	import files.*;	import load.*;	import images.*;	import customFMS.FMSHandler;	import qr.GenerateQRText;	import com.danielfreeman.madcomponents.UIList;		public class AdminConsole extends Sprite {				private var gameGrid:Grid;		private var cols:int = stage.stageWidth / 25;		private var rows:int = stage.stageHeight / 25;		public var xmlNumber:int = 0;		private var isCreated:int = 0;		private var clip:DraggableImage		private var currentFloor:int = 1;		private var floorText:TextField;				//holds completed grid xml		private var completedFloor:Array = new Array();				//server paths		private var m_basePath:String = 'http://wdmdsrv1.uwsp.edu/MobileUWSPApp/';// set this to your web server path 'http://YOURSITE.com/';		private var m_uploadPath:String = 'uploads/';// set this to the folder on your server where you will allow images to be uploaded ( folder permissions must be set to 777 );		private var m_outputPath:String = 'output/';// set this to the folder on your server where images should be created; ( folder permissions must be set to 777 );		private var qrgen:String = "generator.php";		private var dPath:String;				private var m_progress : Sprite = new Sprite();// upload / download indicator;		private var m_fileMgr:FileManager;// manages the opening & upload of local files;		private var m_imagePHP:String = 'image.php';// file that will manage image upload on your server;		private var m_imageQuality:Number = 70;// jpeg or png export quality;		private var m_downloader:GraphicLoader;// handles image download ( after upload is complete );		private var m_imageExtension:String = '.jpg';// jpeg image extension;				private var select:UIButton;		private var finalImage:Loader;				private var sideMenu:SidebarMenu;		private var upload:UIButton;		private var trash:UIButton;		private var confirm:TextField;		private var optionsHolder:Sprite;		private var imageByte:ByteArray;		private var popup:CustomPopup;		private var tutorialAsk:CustomPopup;		private var tutLoader:Loader;		private var exitTut:UIButton;				private var mapBtn:UIButton;		private var qrBtn:UIButton;				//QR variables		private var nameBtn:UIButton;		private var recordBtn:UIButton;		private var audioBtn:UIButton;		private var videoBtn:UIButton;		private var imageBtn:UIButton;		private var createBtn:UIButton;		private var backBtn:UIButton;		private var exitAsk:CustomPopup;		private var fms:FMSHandler;		private var qrName:String;		private var nameCreate:CreateName;		private var str3:String;		private var qrText:String = "none";		private var imageName:String;		private var qrList:UIList;		private var patientData:Array;		private var qrDataString:String;				private var audioRec = false;		private var videoRec = false;		private var imageUploaded = false;				private var frontLayer:Sprite = new Sprite();		private var backLayer:Sprite = new Sprite();				private var _state:String;		public function AdminConsole() {			// set up stage;			stage.align = StageAlign.TOP_LEFT;			stage.scaleMode = StageScaleMode.NO_SCALE;							// allow script access;			Security.allowDomain( 'http://wdmdsrv1.uwsp.edu' );			// replace * with your domain;			Security.allowInsecureDomain( 'http://wdmdsrv1.uwsp.edu' );						menu();		}				private function menu() :void {			//add back and front layer sprites that hold large amounts of content			backLayer = new Sprite();			frontLayer = new Sprite();			addChild(backLayer);			addChild(frontLayer);						mapBtn = new UIButton(275, 75, "Map Editor", 0x000000, 30, new mapEditorIcon());			mapBtn.x = stage.stageWidth / 2 - mapBtn.width / 2;			mapBtn.y = stage.stageHeight / 2 - mapBtn.height / 2 - 50;			mapBtn.addEventListener(UIButton.CLICKED, map);			frontLayer.addChild(mapBtn);						qrBtn = new UIButton(275, 75, "QR", 0x000000, 30, new qrIcon());			qrBtn.x = stage.stageWidth / 2 - qrBtn.width / 2;			qrBtn.y = stage.stageHeight / 2 - qrBtn.height / 2 + 50;			qrBtn.addEventListener(UIButton.CLICKED, qr);			frontLayer.addChild(qrBtn);						backBtn = new UIButton(50, 50, "", 0x000000, 22, new exitIcon());			backBtn.x = stage.stageWidth - backBtn.width;			backBtn.addEventListener(UIButton.CLICKED, confirmExit);			addChild(backBtn);			backBtn.hide();		}				private function map(event:Event) :void {			_state = "Map";						//remove menu buttons / event listeners			mapBtn.removeEventListener(UIButton.CLICKED, map);			qrBtn.removeEventListener(UIButton.CLICKED, qr);			mapBtn.hide();			qrBtn.hide();						// set progress bar to zero scale;			m_progress.scaleX = 0;						// set up file manager;			m_fileMgr = new FileManager(uploadPath, m_uploadPath);			m_fileMgr.addEventListener("FileSelected", encodeImage);			m_fileMgr.addEventListener( FileManager.ON_PROGRESS, onUploadProgress );						select = new UIButton(225, 75, "Select Image", 0x000000, 30);			select.x = stage.stageWidth / 2 - select.width / 2;			select.y = stage.stageHeight / 2 - select.height / 2;			select.addEventListener(UIButton.CLICKED, uploadImage);			frontLayer.addChild(select);						backBtn.show();						// create progress indicator;			with ( m_progress.graphics )			{				beginFill( 0x000000 );				drawRect( 0, 0, select.width, 3 );			}			frontLayer.addChild( m_progress );			m_progress.x = select.x;			m_progress.y = select.y + select.height + 5;		}				private function qr(event:Event):void {			_state = "QR";						//remove menu buttons / event listeners			mapBtn.removeEventListener(UIButton.CLICKED, map);			qrBtn.removeEventListener(UIButton.CLICKED, qr);			frontLayer.removeChild(mapBtn);			frontLayer.removeChild(qrBtn);						m_fileMgr = new FileManager(uploadPath, m_uploadPath);			m_fileMgr.addEventListener("FileSelected", encodeImageQR);			m_fileMgr.addEventListener( FileManager.ON_PROGRESS, onUploadProgress);						//add qr buttons			nameBtn = new UIButton(225, 75, "Name", 0x990000, 30);			nameBtn.addEventListener(UIButton.CLICKED, hideEnterName);			nameBtn.x = 5;			frontLayer.addChild(nameBtn);			imageBtn = new UIButton(225, 75, "Select Image", 0x000000, 30);			imageBtn.x = nameBtn.x + 230;			frontLayer.addChild(imageBtn);			audioBtn = new UIButton(225, 75, "Record Audio", 0x00CC00, 30);			audioBtn.x = imageBtn.x + 230;			frontLayer.addChild(audioBtn);			videoBtn = new UIButton(225, 75, "Record Video", 0x669900, 30);			videoBtn.x = audioBtn.x + 230;			frontLayer.addChild(videoBtn);						createBtn = new UIButton(225, 75, "Create QR", 0x0099CC, 30);			createBtn.x = stage.stageWidth - createBtn.width - 5;			createBtn.y = stage.stageHeight - createBtn.height - 5;			frontLayer.addChild(createBtn);						select = new UIButton(225, 75, "", 0x000000, 30);			select.x = stage.stageWidth / 2 - select.width / 2;			select.y = stage.stageHeight / 2 - select.height / 2;			select.visible = false;			frontLayer.addChild(select);						backBtn.show();						createBtn.dim();			audioBtn.dim();			videoBtn.dim();			imageBtn.dim();						//creates list with selectable patients			enterName();		}				/**		*browse for image files on click of upload button;		**/		private function onBrowse(event:Event):void		{			m_fileMgr.browse();		}				/**		*starts a new instance of the FMS class, connects to FMS		**/		private function recordAudio(event:Event) :void {			if(!fms) {				fms = new FMSHandler(320, 260, 0, 0);				frontLayer.addChild(fms);				fms.addEventListener("Connected", createAudio);								recordBtn = new UIButton(150, 30, "Record", 0x00CC00, 30);				recordBtn.x = fms.x - recordBtn.width;				frontLayer.addChild(recordBtn);			}			else {				fms.recordAudio(qrName);				recordBtn.removeEventListener(UIButton.CLICKED, startRecordingVideo);				recordBtn.addEventListener(UIButton.CLICKED, startRecording);			}						recordBtn.show();			recordBtn.x = 661;			recordBtn.y = 560;						centerFMS();			fms.setAudio();		}				//records audio on FMS		private function createAudio(event:Event) {			fms.removeEventListener("Connected", createAudio);			recordBtn.addEventListener(UIButton.CLICKED, startRecording);			fms.recordAudio(qrName);		}				/**		*hides the audio record UI		**/		private function hideAudio(event:Event) :void {			recordBtn.hide();			frontLayer.removeChild(fms);			audioBtn.addEventListener(UIButton.CLICKED, recordAudio);			audioBtn.removeEventListener(UIButton.CLICKED, hideAudio);		}				/**		*if the rec button is pressed start recording audio to the FMS		**/		private function startRecording(event:Event) :void {			fms.audioHandle.publish();			recordBtn.removeEventListener(UIButton.CLICKED, startRecording);			recordBtn.addEventListener(UIButton.CLICKED, stopRecording);		}				/**		*stop the recording to the FMS		**/		private function stopRecording(event:Event) :void {			fms.stopAudio();			recordBtn.addEventListener(UIButton.CLICKED, startRecording);			recordBtn.removeEventListener(UIButton.CLICKED, stopRecording);						createBtn.addEventListener(UIButton.CLICKED, createQR);			createBtn.show();			audioRec = true;		}				//records video on FMS		private function recordVideo(event:Event) :void {			if(!fms) {				fms = new FMSHandler(320, 260, 0, 0);				frontLayer.addChild(fms);				fms.addEventListener("Connected", createVideo);				recordBtn = new UIButton(150, 30, "Record", 0x00CC00, 30);				recordBtn.x = fms.x - recordBtn.width;				frontLayer.addChild(recordBtn);			}			else {				fms.createVideo(640, 480, qrName);				recordBtn.removeEventListener(UIButton.CLICKED, startRecording);				recordBtn.addEventListener(UIButton.CLICKED, startRecordingVideo);							}			recordBtn.show();			recordBtn.x = 661;			recordBtn.y = 560;			centerFMS();			fms.setVideo();		}				//centers FMS on the stage		private function centerFMS() :void {			fms.x = (stage.stageWidth / 2) - (fms.width / 2);			fms.y = (stage.stageHeight / 2) - (fms.height / 2);		}				//creates video on FMS		private function createVideo(event:Event) {			recordBtn.addEventListener(UIButton.CLICKED, startRecordingVideo);			fms.removeEventListener("Connected", createVideo);			fms.createVideo(640, 480, qrName);		}				/**		*if the rec button is pressed start recording audio to the FMS		**/		private function startRecordingVideo(event:Event) :void {			fms.vidHandle.publish();			recordBtn.removeEventListener(UIButton.CLICKED, startRecordingVideo);			recordBtn.addEventListener(UIButton.CLICKED, stopRecordingVideo);		}				//stop video recording		private function stopRecordingVideo(event:Event) :void {			fms.stopVideo();						recordBtn.removeEventListener(UIButton.CLICKED, stopRecordingVideo);			recordBtn.addEventListener(UIButton.CLICKED, startRecordingVideo);						createBtn.addEventListener(UIButton.CLICKED, createQR);			createBtn.show();			videoRec = true;		}				/**		*send data to the desired php file to create a new QR code		**/		private function createQR(event:Event) :void {						//send qr text to QR generator code			var request:URLRequest = new URLRequest (m_basePath + qrgen); 			request.method = URLRequestMethod.POST;						var variables:URLVariables = new URLVariables(); 			var generate:GenerateQRText = new GenerateQRText();						variables.name = qrName;			//if Patient is selected from radio menu			if(str3 == "Patient") {				variables.qrText = qrDataString; 			} 			//if Department is selected from radio menu			else if(str3 == "Department") {				variables.qrText = generate.generateDepartmentQRText(qrName, qrText);			}			variables.text = qrText;			request.data = variables; 						//loads qr code			var loader:URLLoader = new URLLoader (request); 			loader.addEventListener(Event.COMPLETE, onComplete); 			loader.dataFormat = URLLoaderDataFormat.TEXT; 			loader.load(request); 						createBtn.removeEventListener( UIButton.CLICKED, createQR );		}				/**		*starts loading the newly created QR code		**/		private function onComplete(event:Event) :void {			var downloader:GraphicLoader = new GraphicLoader();			downloader.addEventListener( GraphicLoader.ON_LOAD_PROGRESS, onDownloadProgress );			downloader.addEventListener( GraphicLoader.ON_LOAD_COMPLETE, onQRDownloaded );			downloader.addEventListener( ErrorEvent.ERROR, onDownloadError );						downloader.loadURL(m_basePath + "imagedownload.php?name=QRCodes/" + event.target.data);		}				/**		*places the loaded QR code in the middle of the stage, moves everything back to their original place		**/		private function onQRDownloaded( e : CustomEvent ):void {			var qrImage:ClickableImage = new ClickableImage(new Bitmap(e.params.loaded.bitmapData.clone()), m_basePath + "imagedownload.php?name=QRCodes/" + qrName + ".png");			qrImage.x = (stage.stageWidth / 2) - (qrImage.width / 2);			qrImage.y = (stage.stageHeight / 2) - (qrImage.height / 2);			frontLayer.addChild(qrImage);						createBtn.hide();			audioBtn.dim();			imageBtn.dim();			nameBtn.dim();			videoBtn.dim();			if(finalImage) 				backLayer.removeChild(finalImage);			try {				frontLayer.removeChild(fms);				recordBtn.hide();			}			catch (e:Error){							}		}				/**		*created the enter name class and places it on the stage		**/		private function enterName(event:Event = null) :void {			//database call to get patient names			var gateway:NetConnection = new NetConnection();			gateway.objectEncoding = 0;			var responder:Responder = new Responder(onResult, onFault);			gateway.connect("http://wdmdsrv1.uwsp.edu/flashservices/gateway/");			gateway.call("Inpatient.Inpatient_Main.forms.getPatients", responder);						nameBtn.addEventListener( UIButton.CLICKED, hideEnterName );		}				//populates list with result containing all patients		private function onResult(event:Object):void {			patientData = event.serverInfo.initialData;			var temp:Array = new Array();			for(var i:int; i < patientData.length; i++) {				temp.push(patientData[i][1] + " " + patientData[i][2] + " - " + patientData[i][3]);			}			nameCreate = new CreateName(300, 420, nameBtn.x, nameBtn.y + nameBtn.height + 5, temp);			nameCreate.addEventListener("Closed", hideEnterName2);			frontLayer.addChild(nameCreate);		}				private function onFault(event:Object):void {			//loop over fault structure 			for (var i:String in event) { 				trace (i + ": " + event[i]); 			}		}				private function hideEnterName2(event:Event) :void {			hideEnterName();		}				/**		*hides the enter name if the text inputs have text in them		**/		private function hideEnterName(event:Event = null) :void {			var str:int = nameCreate._itemClicked;			var str2:String = nameCreate.returnInput2();			str3 = nameCreate.returnRadio();			//if patient selected from radio menu, and other strings aren't blank			if(str != -1 && str2 != "" && str3 == "Patient") {				TweenFilterLite.to( nameCreate, 1, { autoAlpha : 0 } );				nameBtn.removeEventListener( UIButton.CLICKED, hideEnterName );								imageBtn.addEventListener( UIButton.CLICKED, onBrowse );				audioBtn.addEventListener( UIButton.CLICKED, recordAudio );				videoBtn.addEventListener( UIButton.CLICKED, recordVideo );				nameCreate.removeEventListener("Closed", hideEnterName2);				imageBtn.show();				audioBtn.show();				videoBtn.show();				nameBtn.dim();								qrName = patientData[str][1] + patientData[str][2] + "QR";				qrText = nameCreate.returnInput2();				qrDataString = "Patient," + patientData[str][0] + "," + patientData[str][3];											}			//if department selected from radio menu, and other strings aren't blank			else if(str != -1 && str2 != "" && str3 == "Department") {				TweenFilterLite.to( nameCreate, 1, { autoAlpha : 0 } );				nameBtn.removeEventListener( UIButton.CLICKED, hideEnterName );				nameCreate.removeEventListener("Closed", hideEnterName2);								createBtn.addEventListener( UIButton.CLICKED, createQR );				createBtn.show();								nameBtn.dim();								qrName = nameCreate.returnInput1();				qrText = nameCreate.returnInput2();				qrDataString = "Patient," + patientData[str][0] + "," + patientData[str][3];			}		}				//encode image from file manager, scale down quality with JPGEncoder		private function encodeImageQR(event:Event) {			nameBtn.hide();			imageBtn.hide();			videoBtn.hide();			audioBtn.hide();			createBtn.hide();						  			var image:Bitmap = Bitmap(m_fileMgr._loaderInfo.content);						var image2:Bitmap = drawScaled(image, stage.stageWidth - 50, stage.stageHeight - 50);			var encode:JPGEncoder = new JPGEncoder(m_imageQuality);			imageByte = encode.encode(image2.bitmapData);						finalImage = new Loader();			finalImage.contentLoaderInfo.addEventListener(Event.COMPLETE, userCheckImage);			finalImage.loadBytes(imageByte);		}				// ************************************** QR ************************************				private function uploadImage(event:Event) :void {			m_fileMgr.browse();			m_fileMgr.addEventListener("FileLoading", setUploadText);		}				private function setUploadText(event:Event) :void {			select.setLabel("Converting...");		}				//encodes image from FileManager, scales quality with JPGEncoder		private function encodeImage(event:Event) {			select.hide();			m_progress.scaleX = 0;						var image:Bitmap = Bitmap(m_fileMgr._loaderInfo.content);						var image2:Bitmap = drawScaled(image, stage.stageWidth - 50, stage.stageHeight - 50);			var encode:JPGEncoder = new JPGEncoder(m_imageQuality);			imageByte = encode.encode(image2.bitmapData);						finalImage = new Loader();			finalImage.contentLoaderInfo.addEventListener(Event.COMPLETE, userCheckImage);			finalImage.loadBytes(imageByte);		}				//asks user if they want to upload image or trash image		private function userCheckImage(event:Event) :void {			backLayer.addChild(finalImage);			finalImage.x = stage.stageWidth / 2 - finalImage.width / 2;						optionsHolder = new Sprite();						upload = new UIButton(100, 40, "Upload", 0x33DD00);			upload.x = stage.stageWidth / 2;			upload.y = stage.stageHeight - upload.height - 5;			upload.addEventListener(UIButton.CLICKED, onUserUpload);			optionsHolder.addChild(upload);			trash = new UIButton(100, 40, "Trash",0xFF0000);			trash.x = stage.stageWidth / 2 + trash.width + 10;			trash.y = stage.stageHeight - trash.height - 5;			trash.addEventListener(UIButton.CLICKED, onUserTrash);			optionsHolder.addChild(trash);						confirm = new TextField();			confirm.text = "Do you want to upload or trash this image?";			confirm.autoSize = TextFieldAutoSize.CENTER;			var format:TextFormat = new TextFormat();			format.size = 20;			confirm.setTextFormat(format);			confirm.x = stage.stageWidth / 2 - confirm.width - 5;			confirm.y = stage.stageHeight - confirm.height - 8;			optionsHolder.addChild(confirm);						frontLayer.addChild(optionsHolder);		}				//User hits upload button once given the option		private function onUserUpload(event:Event):void {			m_fileMgr.addEventListener(CustomEvent.CUSTOM_EVENT, onImageUploaded);						//send byte array with image data to FileManager class			m_fileMgr.uploadImage(imageByte, _state);		}				//User hits trash button once given the option		private function onUserTrash(event:Event):void {			if(_state == "QR") {				TweenLite.to(finalImage, 1, {x:trash.x, y:trash.y, scaleX:0.1, scaleY:0.1, alpha:0, onComplete:resetLoader});				optionsHolder.removeChild(upload);				optionsHolder.removeChild(confirm);			}			else if(_state == "Map") {				select.show();				TweenLite.to(finalImage, 1, {x:trash.x, y:trash.y, scaleX:0.1, scaleY:0.1, alpha:0, onComplete:resetLoader});				select.setLabel("Trashing...");				m_progress.scaleX = 0;				optionsHolder.removeChild(upload);				optionsHolder.removeChild(confirm);			}		}				private function resetLoader():void {			//kill loader that holds image			finalImage.unload();			backLayer.removeChild(finalImage);						//remove upload and trash buttons, and text field			frontLayer.removeChild(optionsHolder);						if(_state == "QR") {				createBtn.show();				audioBtn.show();				imageBtn.show();				nameBtn.dim();				videoBtn.show();			}			else if(_state == "Map") {				//change main button text back to upload				select.setLabel("Select Image");			}		}				//scales image		private function drawScaled(obj:DisplayObject, w:int, h:int) :Bitmap {			var m:Matrix = new Matrix();			m.scale(w / obj.width, h / obj.height);			var bmp:BitmapData = new BitmapData(w, h, false);			bmp.draw(obj, m);			return new Bitmap(bmp);		}				/**		*track image upload progress;		**/		private function onUploadProgress( e : CustomEvent ):void		{			//trace( 'image uploading : ' + e.params.percent );			m_progress.scaleX = e.params.percent;		}				/**		*fires if there is an error during upload;		**/		private function onUploadError( e : CustomEvent ):void		{			trace( 'upload error' );		}		//************END ALL BE ALL CODE****************		/*public function onClick(e:MouseEvent):void {			gameGrid.plot[e.currentTarget.plot[Math.round(mouseX / 25)][Math.round(mouseY / 25)].col - 1][e.currentTarget.plot[Math.round(mouseX / 25)][Math.round((mouseY - 14) / 25)].row].gotoAndStop(selectedRb);		}*/				//square on grid is clicked		public function onClick(e:MouseEvent):void {			gameGrid.plot[e.currentTarget.plot[Math.round(mouseX / 25)][Math.round(mouseY / 25)].col - 1][e.currentTarget.plot[Math.round(mouseX / 25)][Math.round((mouseY - 14) / 25)].row].gotoAndStop(sideMenu.selectedRb);		}				/**		*fires when image upload is complete;		**/		public function onImageUploaded( e :CustomEvent ):void		{			TweenLite.to(optionsHolder, 1, {alpha:0});						//if user is on the Map Editor side			if (_state == "Map") {				TweenLite.to(finalImage, 1, {y:(stage.stageHeight / 2) - (finalImage.height / 2)});								gameGrid = new Grid(Box,stage.stageHeight / 25,stage.stageWidth / 25,0);				gameGrid.addEventListener(MouseEvent.CLICK, onClick);				backLayer.addChild(gameGrid);								if (isCreated == 0)				{					//instantiate menu here					sideMenu = new SidebarMenu();					sideMenu.x = 1085;					sideMenu.y = stage.stageHeight / 2 - sideMenu.height / 2;					frontLayer.addChild(sideMenu);					//listen for user hitting the clear button					sideMenu.addEventListener("ON_MAP_CLEAR", clearGrid);					sideMenu.addEventListener("CREATE_NEW_FLOOR", clearMap);					sideMenu.addEventListener("EXPORT_XML", exportXML);					backBtn.show();										isCreated++;				} else {					sideMenu.x = 1085;					backBtn.show();				}					//increment xmlNumber so each saved file is a different name				xmlNumber++;								select.hide();				TweenFilterLite.to( sideMenu, 1, { autoAlpha : 1 } );				gameGrid.visible = true;												//display popup to ask about tutorial				tutorialAsk = new CustomPopup(450, 200, "Would you like to view a tutorial?");				tutorialAsk.x = stage.stageWidth / 2 - tutorialAsk.width / 2;				tutorialAsk.y = stage.stageHeight / 2 - tutorialAsk.height / 2;				tutorialAsk.addEventListener("ON_YES_CLICK", yesTutorial);				tutorialAsk.alpha = 0;				frontLayer.addChild(tutorialAsk);				TweenLite.to(tutorialAsk, .2, {alpha:1});			//if user is on the QR side			} else if (_state == "QR") {				TweenLite.to(finalImage, 1, {y:(imageBtn.y) + (imageBtn.height + 5), x:(imageBtn.x), scaleX:0.2, scaleY:0.2});				createBtn.show();				audioBtn.show();				imageBtn.show();				nameBtn.dim();				videoBtn.show();								createBtn.addEventListener(UIButton.CLICKED, createQR);			}				}				//asks user if they want to exit		private function confirmExit(event:Event):void {			exitAsk = new CustomPopup(450, 200, "Are you sure you want to exit?");			exitAsk.x = stage.stageWidth / 2 - exitAsk.width / 2;			exitAsk.y = stage.stageHeight /  2 - exitAsk.height / 2;			exitAsk.addEventListener("ON_YES_CLICK", yesExit);			exitAsk.alpha = 0;			frontLayer.addChild(exitAsk);			TweenLite.to(exitAsk, .2, {alpha:1});		}				private function yesExit(event:Event):void {			removeChild(backLayer);			removeChild(frontLayer);			removeChild(backBtn);			menu();		}				//loads tutorial if user selects yes		private function yesTutorial(event:Event):void {			tutLoader = new Loader();  			tutLoader.contentLoaderInfo.addEventListener(Event.COMPLETE, playTutorial);			var url:URLRequest = new URLRequest("assets/mapEditorTutorial.swf"); 			tutLoader.load(url);		}				//starts tutorial		private function playTutorial(event:Event):void { 			//add tutorial to the stage			frontLayer.addChild(tutLoader);						exitTut = new UIButton(120, 50, "Exit Tutorial", 0xFF0000);			exitTut.x = stage.stageWidth / 2 - exitTut.width / 2;			exitTut.y = 0;			exitTut.addEventListener(UIButton.CLICKED, exitTutorial);			frontLayer.addChild(exitTut);		}				private function exitTutorial(event:Event):void {			tutLoader.unload();			frontLayer.removeChild(tutLoader);			frontLayer.removeChild(exitTut);		}				//generate popup asking for confirmation to clear map		private function clearGrid(event:Event):void {			popup = new CustomPopup(450, 200, "Are you sure you want to CLEAR the map?");			popup.x = stage.stageWidth / 2 - popup.width / 2;			popup.y = stage.stageHeight / 2 - popup.height / 2;			popup.addEventListener("ON_YES_CLICK", yesClear);			popup.alpha = 0;			frontLayer.addChild(popup);			TweenLite.to(popup, .2, {alpha:1});		}				//yes from popup selected, loop through every grid square and set it to frame 1, which is clear		private function yesClear(event:Event):void {			for (var i:Number=0; i < 48; i++){				for (var j:Number=0; j < 33; j++){					gameGrid.plot[i][j].gotoAndStop(1);				}			}		}				/**		*track image download progress;		**/		private function onDownloadProgress( e : CustomEvent ):void		{			//trace( 'image downloading : ' + e.params.percent );			m_progress.scaleX = 1 - e.params.percent;		}		/**		*fires if there is an error during download;		**/		private function onDownloadError( e : ErrorEvent ):void		{			trace( 'download error' );		}				//exports each floor into XML, based on what squares are filled out on the Grid		private function exportXML(event:Event):void		{			//if they are only on the first floor when they export			if (completedFloor.length == 0)			{				var xmlArray:Array = new Array();				//goes through every column in the Grid				for (var c:uint = 0; c<cols; c++)				{					//goes through every row in the Grid					for (var r:uint = 0; r<rows; r++)					{						//if currentFrame is not blank (1 = blank square)						if (gameGrid.plot[c][r].currentFrame > 1)						{							//creates xml, and pushes that into the xmlArray (an array where pieces of xml are added)							var xml:String = "<clip><col>" + gameGrid.plot[c][r].col + "</col><row>" + 							gameGrid.plot[c][r].row + "</row><frame>" + gameGrid.plot[c][r].currentFrame + "</frame></clip>";							xmlArray.push(xml);						}					}				}								var completedGrid:String;				//loops through xmlArray and puts it into a string (this will hold all of the floors)				for (var j:uint = 0; j < xmlArray.length; j++)				{					completedGrid = completedGrid + xmlArray[j];				}				completedGrid = "<grid><floor>" + completedGrid + "</floor></grid>";								//cycle through mapXML and remove all nulls				var myPattern:RegExp = /null/gi;				completedGrid = completedGrid.replace(myPattern, "");								//create new XML variable from the completedGrid string				var mapXML:XML = new XML(completedGrid);				var ba:ByteArray = new ByteArray();				//write mapXML to a ByteArray                ba.writeUTFBytes(mapXML);								//upload xml to server				var xmlManager:FileManager = new FileManager('http://wdmdsrv1.uwsp.edu/MobileUWSPApp/xml/xmlUpload.php', 'xml/');				xmlManager.addEventListener( FileManager.ON_PROGRESS, onXMLUploadProgress );				xmlManager.addEventListener( FileManager.ON_UPLOAD_ERROR, xmlError );				xmlManager.addEventListener( FileManager.ON_IMAGE_UPLOADED, xmlUploaded );				//send byte array with image data to FileManager class				xmlManager.uploadXML(ba, 'hospitalMap.xml');				xmlManager.addEventListener(XMLEvent.ON_XML_UPLOADED, onXMLUploaded);											}			//if there is more than 1 floor completed			else if (completedFloor.length > 0)			{				pushGrid();				var completedGrid2:String;								for (var q:uint = 0; q < completedFloor.length; q++)				{					completedGrid2 = completedGrid2 + completedFloor[q];				}								completedGrid2 = "<grid>" + completedGrid2 + "</grid>";				var mapXML2:XML = new XML(completedGrid2);								var ba2:ByteArray = new ByteArray();				ba2.writeUTFBytes(mapXML2);			}		}				private function onXMLUploaded(event:XMLEvent):void {			trace(event.params.fileName);		}				private function xmlUploaded(event:CustomEvent) :void {			trace(event.params.percent);		}				private function xmlError(event:CustomEvent) :void {			trace("Error uploading XML");		}				private function onXMLUploadProgress( e : CustomEvent ):void		{			trace( "Image uploading : " + e.params.percent );		}		//clears grid and resets all squares to blank		private function clearMap(event:Event):void		{				pushGrid();			TweenLite.to(finalImage, .5, {alpha:0, onComplete:function deletePopup():void {finalImage.unload(); backLayer.removeChild(finalImage);}});			currentFloor++;			//sets current floor in side menu class			sideMenu.setFloor(currentFloor);			TweenLite.to(sideMenu, .5, {x:stage.stageWidth + sideMenu.width});			TweenLite.to(gameGrid, .5, {alpha:0, onComplete:function deletePopup():void {backLayer.removeChild(gameGrid);}});			select.show();			select.setLabel("Select Image");		}				//pushes the xml equivilant of the Grid into an array		private function pushGrid():void {			var xmlArray:Array = new Array();			//loops through all columns in Grid			for (var c:uint = 0; c<cols; c++)			{				//loops through all rows in Grid				for (var r:uint = 0; r<rows; r++)				{					//if that specific square isn't blank (1 = blank square)					if (gameGrid.plot[c][r].currentFrame > 1)					{						//creates xml string with the currentFrame number, and pushes it into xmlArray						var xml:String = "<clip><col>" + gameGrid.plot[c][r].col + "</col><row>" + 						gameGrid.plot[c][r].row + "</row><frame>" + gameGrid.plot[c][r].currentFrame + "</frame></clip>";						xmlArray.push(xml);					}					//since this function is called to move to a new floor, reset each square to blank after the xml is pushed into array					gameGrid.plot[c][r].gotoAndStop(1);					gameGrid.visible = false;				}			}			var completedGrid:String;			//loops through xmlArray and puts it into a string (this will hold all of the floors)			for (var j:uint = 0; j < xmlArray.length; j++)			{				completedGrid = completedGrid + xmlArray[j];			}			completedGrid = "<floor><imagePath>" + m_basePath + 'imagedownload.php?name=' + m_fileMgr.m_fileName + "</imagePath>" + completedGrid + "</floor>";			//pushes a completed floor (completedGrid) into an array that holds all completed floors (completedFloor)			completedFloor.push(completedGrid);		}				/**		*returns upload php file path based on whether or not the swf is a local publish or hosted on a web server;		**/		public function get uploadPath():String		{			return m_basePath + m_imagePHP;		}	}	}